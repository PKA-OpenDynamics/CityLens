# Copyright (c) 2025 CityLens Contributors
# Licensed under the GNU General Public License v3.0 (GPL-3.0)

"""
Mobile App Alerts Endpoints
API routes for mobile app alert management
Uses MongoDB Atlas
"""

from fastapi import APIRouter, Depends, HTTPException, status, Query, Header
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime
from pydantic import BaseModel, Field
from bson import ObjectId

from app.db.mongodb_atlas import get_mongodb_atlas
from app.services.auth_service import auth_service as web_auth_service

router = APIRouter()


class AlertCreate(BaseModel):
    """Schema for creating a new alert"""
    type: str = Field(..., description="Alert type: environment, traffic, civic, parking, health, safety")
    severity: str = Field(..., description="Severity: critical, warning, info")
    title: str = Field(..., description="Alert title in Vietnamese")
    description: str = Field(..., description="Alert description")
    ward: Optional[str] = Field(None, description="Ward/Phường name")
    recommendation: Optional[str] = Field(None, description="Recommended action")
    impact: Optional[str] = Field(None, description="Impact assessment")
    affectedPopulation: Optional[str] = Field(None, description="Affected population estimate")
    isAIGenerated: bool = Field(False, description="Whether generated by AI")


class AlertResponse(BaseModel):
    """Response schema for alerts"""
    success: bool
    data: dict
    message: Optional[str] = None


class AlertListResponse(BaseModel):
    """Response schema for alert list"""
    success: bool
    data: List[dict]
    count: int


@router.post("/", response_model=AlertResponse, status_code=status.HTTP_201_CREATED)
async def create_alert(
    alert_data: AlertCreate,
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Create a new alert for mobile app
    
    - **type**: Alert type (environment, traffic, civic, parking, health, safety)
    - **severity**: Severity level (critical, warning, info)
    - **title**: Alert title in Vietnamese
    - **description**: Detailed description
    - **ward**: Ward/Phường where alert applies
    - **recommendation**: Recommended action for citizens
    """
    # Create alert document
    alert_doc = {
        "_id": ObjectId(),
        "type": alert_data.type,
        "severity": alert_data.severity,
        "title": alert_data.title,
        "description": alert_data.description,
        "ward": alert_data.ward,
        "recommendation": alert_data.recommendation,
        "impact": alert_data.impact,
        "affectedPopulation": alert_data.affectedPopulation,
        "isAIGenerated": alert_data.isAIGenerated,
        "status": "active",
        "createdAt": datetime.utcnow(),
        "updatedAt": datetime.utcnow(),
        "createdBy": "system",
    }
    
    # Insert into MongoDB
    collection = db.alerts
    result = await collection.insert_one(alert_doc)
    
    # Convert ObjectId to string for response
    alert_doc["_id"] = str(alert_doc["_id"])
    alert_doc["createdAt"] = alert_doc["createdAt"].isoformat()
    alert_doc["updatedAt"] = alert_doc["updatedAt"].isoformat()
    
    return AlertResponse(
        success=True,
        data=alert_doc,
        message="Đã tạo cảnh báo thành công"
    )


@router.get("/", response_model=AlertListResponse)
async def get_alerts(
    status: Optional[str] = Query(None, description="Filter by status: active, acknowledged, resolved"),
    severity: Optional[str] = Query(None, description="Filter by severity: critical, warning, info"),
    ward: Optional[str] = Query(None, description="Filter by ward"),
    limit: int = Query(50, ge=1, le=100, description="Number of alerts to return"),
    skip: int = Query(0, ge=0, description="Number of alerts to skip"),
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Get alerts list for mobile app
    
    Supports filtering by status, severity, and ward
    """
    collection = db.alerts
    
    # Build query
    query = {}
    if status:
        query["status"] = status
    if severity:
        query["severity"] = severity
    if ward:
        query["ward"] = {"$regex": ward, "$options": "i"}
    
    # Get alerts
    cursor = collection.find(query).sort("createdAt", -1).skip(skip).limit(limit)
    alerts = await cursor.to_list(length=limit)
    
    # Convert ObjectId to string
    for alert in alerts:
        alert["_id"] = str(alert["_id"])
        if isinstance(alert.get("createdAt"), datetime):
            alert["createdAt"] = alert["createdAt"].isoformat()
        if isinstance(alert.get("updatedAt"), datetime):
            alert["updatedAt"] = alert["updatedAt"].isoformat()
    
    return AlertListResponse(
        success=True,
        data=alerts,
        count=len(alerts)
    )


@router.get("/active", response_model=AlertListResponse)
async def get_active_alerts(
    ward: Optional[str] = Query(None, description="Filter by ward"),
    limit: int = Query(20, ge=1, le=50),
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Get active alerts for mobile app (for notifications)
    
    Returns only active alerts, sorted by severity and time
    """
    collection = db.alerts
    
    query = {"status": "active"}
    if ward:
        query["ward"] = {"$regex": ward, "$options": "i"}
    
    # Sort by severity (critical first) then by time
    severity_order = {"critical": 0, "warning": 1, "info": 2}
    
    cursor = collection.find(query).sort([
        ("createdAt", -1)
    ]).limit(limit)
    
    alerts = await cursor.to_list(length=limit)
    
    # Sort by severity in Python (MongoDB can't easily sort by custom order)
    alerts.sort(key=lambda x: (severity_order.get(x.get("severity", "info"), 2), x.get("createdAt", "")))
    
    # Convert ObjectId to string
    for alert in alerts:
        alert["_id"] = str(alert["_id"])
        if isinstance(alert.get("createdAt"), datetime):
            alert["createdAt"] = alert["createdAt"].isoformat()
        if isinstance(alert.get("updatedAt"), datetime):
            alert["updatedAt"] = alert["updatedAt"].isoformat()
    
    return AlertListResponse(
        success=True,
        data=alerts,
        count=len(alerts)
    )


@router.put("/{alert_id}")
async def update_alert(
    alert_id: str,
    alert_data: AlertCreate,
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Update an existing alert
    """
    collection = db.alerts
    
    update_data = {
        "type": alert_data.type,
        "severity": alert_data.severity,
        "title": alert_data.title,
        "description": alert_data.description,
        "ward": alert_data.ward,
        "recommendation": alert_data.recommendation,
        "impact": alert_data.impact,
        "affectedPopulation": alert_data.affectedPopulation,
        "isAIGenerated": alert_data.isAIGenerated,
        "updatedAt": datetime.utcnow(),
    }
    
    result = await collection.update_one(
        {"_id": ObjectId(alert_id)},
        {"$set": update_data}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
    
    return {"success": True, "message": "Đã cập nhật cảnh báo"}


@router.put("/{alert_id}/status")
async def update_alert_status(
    alert_id: str,
    new_status: str = Query(..., description="New status: active, acknowledged, resolved"),
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Update alert status
    """
    collection = db.alerts
    result = await collection.update_one(
        {"_id": ObjectId(alert_id)},
        {"$set": {"status": new_status, "updatedAt": datetime.utcnow()}}
    )
    
    if result.modified_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
    
    return {"success": True, "message": f"Đã cập nhật trạng thái thành {new_status}"}


@router.delete("/{alert_id}")
async def delete_alert(
    alert_id: str,
    db: AsyncIOMotorDatabase = Depends(get_mongodb_atlas)
):
    """
    Delete an alert
    """
    collection = db.alerts
    result = await collection.delete_one({"_id": ObjectId(alert_id)})
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Alert not found")
    
    return {"success": True, "message": "Đã xóa cảnh báo"}
